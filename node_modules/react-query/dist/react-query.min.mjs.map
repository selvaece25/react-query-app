{"version":3,"file":"react-query.min.mjs","sources":["../src/utils.js","../src/config.js","../src/queryCache.js","../src/setFocusHandler.js","../src/useIsFetching.js","../src/useMutation.js","../src/useBaseQuery.js","../src/useQuery.js","../src/usePaginatedQuery.js","../src/useInfiniteQuery.js"],"sourcesContent":["import React from 'react'\n\n//\n\nexport const statusIdle = 'idle'\nexport const statusLoading = 'loading'\nexport const statusError = 'error'\nexport const statusSuccess = 'success'\n\nlet _uid = 0\nexport const uid = () => _uid++\nexport const cancelledError = {}\nexport let globalStateListeners = []\nexport const isServer = typeof window === 'undefined'\nexport const noop = () => {}\nexport const identity = d => d\nexport let Console = console || { error: noop, warn: noop, log: noop }\n\nexport function useUid() {\n  const ref = React.useRef(null)\n\n  if (ref.current === null) {\n    ref.current = uid()\n  }\n\n  return ref.current\n}\n\nexport function setConsole(c) {\n  Console = c\n}\n\nexport function useGetLatest(obj) {\n  const ref = React.useRef()\n  ref.current = obj\n\n  return React.useCallback(() => ref.current, [])\n}\n\nexport function functionalUpdate(updater, old) {\n  return typeof updater === 'function' ? updater(old) : updater\n}\n\nexport function stableStringifyReplacer(_, value) {\n  return isObject(value)\n    ? Object.assign(\n        {},\n        ...Object.keys(value)\n          .sort()\n          .map(key => ({\n            [key]: value[key],\n          }))\n      )\n    : value\n}\n\nexport function stableStringify(obj) {\n  return JSON.stringify(obj, stableStringifyReplacer)\n}\n\nexport function isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\nexport function deepIncludes(a, b) {\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return a === b\n}\n\nexport function isDocumentVisible() {\n  return (\n    typeof document === 'undefined' ||\n    document.visibilityState === undefined ||\n    document.visibilityState === 'visible' ||\n    document.visibilityState === 'prerender'\n  )\n}\n\nexport function isOnline() {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs(args) {\n  if (isObject(args[0])) {\n    if (\n      args[0].hasOwnProperty('queryKey') &&\n      args[0].hasOwnProperty('queryFn')\n    ) {\n      const { queryKey, variables = [], queryFn, config = {} } = args[0]\n      return [queryKey, variables, queryFn, config]\n    } else {\n      throw new Error('queryKey and queryFn keys are required.')\n    }\n  }\n  if (typeof args[2] === 'function') {\n    const [queryKey, variables = [], queryFn, config = {}] = args\n    return [queryKey, variables, queryFn, config]\n  }\n\n  const [queryKey, queryFn, config = {}] = args\n\n  return [queryKey, [], queryFn, config]\n}\n\nexport function useMountedCallback(callback) {\n  const mounted = React.useRef(false)\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mounted.current = true\n    return () => (mounted.current = false)\n  }, [])\n  return React.useCallback(\n    (...args) => (mounted.current ? callback(...args) : void 0),\n    [callback]\n  )\n}\n\nexport function handleSuspense(query) {\n  if (query.config.suspense || query.config.useErrorBoundary) {\n    if (query.status === statusError) {\n      throw query.error\n    }\n  }\n\n  if (query.config.suspense) {\n    if (query.status === statusLoading) {\n      query.wasSuspensed = true\n      throw query.refetch()\n    }\n  }\n}\n","import React from 'react'\nimport { noop, stableStringify, identity } from './utils'\n\nexport const configContext = React.createContext()\n\nexport const defaultConfigRef = {\n  current: {\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: 0,\n    cacheTime: 5 * 60 * 1000,\n    refetchAllOnWindowFocus: true,\n    refetchInterval: false,\n    suspense: false,\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    queryFnParamsFilter: identity,\n    throwOnError: false,\n    useErrorBoundary: undefined, // this will default to the suspense value\n    onMutate: noop,\n    onSuccess: noop,\n    onError: noop,\n    onSettled: noop,\n    refetchOnMount: true,\n  },\n}\n\nexport function useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current\n}\n\nexport function ReactQueryConfigProvider({ config, children }) {\n  let configContextValue = React.useContext(configContext)\n\n  const newConfig = React.useMemo(() => {\n    const newConfig = {\n      ...(configContextValue || defaultConfigRef.current),\n      ...config,\n    }\n\n    // Default useErrorBoundary to the suspense value\n    if (typeof newConfig.useErrorBoundary === 'undefined') {\n      newConfig.useErrorBoundary = newConfig.suspense\n    }\n\n    return newConfig\n  }, [config, configContextValue])\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig\n  }\n\n  return (\n    <configContext.Provider value={newConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n\nexport function defaultQueryKeySerializerFn(queryKey) {\n  if (!queryKey) {\n    return []\n  }\n\n  if (typeof queryKey === 'function') {\n    try {\n      return defaultQueryKeySerializerFn(queryKey())\n    } catch {\n      return []\n    }\n  }\n\n  if (typeof queryKey === 'string') {\n    queryKey = [queryKey]\n  }\n\n  const queryHash = stableStringify(queryKey)\n  queryKey = JSON.parse(queryHash)\n\n  return [queryHash, queryKey]\n}\n","import {\n  isServer,\n  functionalUpdate,\n  cancelledError,\n  isDocumentVisible,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  getQueryArgs,\n  deepIncludes,\n  noop,\n} from './utils'\nimport { defaultConfigRef } from './config'\n\nexport const queryCache = makeQueryCache()\n\nconst actionInit = {}\nconst actionFailed = {}\nconst actionMarkStale = {}\nconst actionMarkGC = {}\nconst actionFetch = {}\nconst actionSuccess = {}\nconst actionError = {}\n\nexport function makeQueryCache() {\n  const listeners = []\n\n  const cache = {\n    queries: {},\n    isFetching: 0,\n  }\n\n  const notifyGlobalListeners = () => {\n    cache.isFetching = Object.values(queryCache.queries).reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n    listeners.forEach(d => d(cache))\n  }\n\n  cache.subscribe = cb => {\n    listeners.push(cb)\n    return () => {\n      listeners.splice(listeners.indexOf(cb), 1)\n    }\n  }\n\n  cache.clear = () => {\n    cache.queries = {}\n    notifyGlobalListeners()\n  }\n\n  const findQueries = (predicate, { exact } = {}) => {\n    if (typeof predicate !== 'function') {\n      const [\n        queryHash,\n        queryKey,\n      ] = defaultConfigRef.current.queryKeySerializerFn(predicate)\n      predicate = d =>\n        exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return Object.values(cache.queries).filter(predicate)\n  }\n\n  cache.getQueries = findQueries\n\n  cache.getQuery = queryKey => findQueries(queryKey, { exact: true })[0]\n\n  cache.getQueryData = queryKey => cache.getQuery(queryKey)?.state.data\n\n  cache.removeQueries = (predicate, { exact } = {}) => {\n    const foundQueries = findQueries(predicate, { exact })\n\n    foundQueries.forEach(query => {\n      clearTimeout(query.staleTimeout)\n      delete cache.queries[query.queryHash]\n    })\n\n    if (foundQueries.length) {\n      notifyGlobalListeners()\n    }\n  }\n\n  cache.refetchQueries = async (\n    predicate,\n    { exact, throwOnError, force } = {}\n  ) => {\n    const foundQueries =\n      predicate === true\n        ? Object.values(cache.queries)\n        : findQueries(predicate, { exact })\n\n    try {\n      return await Promise.all(\n        foundQueries.map(query => query.fetch({ force }))\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  cache._buildQuery = (userQueryKey, queryVariables, queryFn, config) => {\n    let [queryHash, queryKey] = config.queryKeySerializerFn(userQueryKey)\n\n    let query = cache.queries[queryHash]\n\n    if (query) {\n      Object.assign(query, { queryVariables, queryFn })\n      Object.assign(query.config, config)\n    } else {\n      query = makeQuery({\n        queryKey,\n        queryHash,\n        queryVariables,\n        queryFn,\n        config,\n      })\n\n      // If the query started with data, schedule\n      // a stale timeout\n      if (query.state.data) {\n        query.scheduleStaleTimeout()\n\n        // Simulate a query healing process\n        query.heal()\n        // Schedule for garbage collection in case\n        // nothing subscribes to this query\n        query.scheduleGarbageCollection()\n      }\n\n      if (query.queryHash) {\n        if (!isServer) {\n          cache.queries[queryHash] = query\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(() => {\n            notifyGlobalListeners()\n          })\n        }\n      }\n    }\n\n    return query\n  }\n\n  cache.prefetchQuery = async (...args) => {\n    let [\n      queryKey,\n      queryVariables,\n      queryFn,\n      { force, ...config },\n    ] = getQueryArgs(args)\n\n    config = {\n      ...defaultConfigRef.current,\n      ...config,\n    }\n\n    const query = cache._buildQuery(queryKey, queryVariables, queryFn, config)\n\n    // Don't prefetch queries that are fresh, unless force is passed\n    if (query.state.isStale || force) {\n      // Trigger a fetch and return the promise\n      try {\n        const res = await query.fetch({ force })\n        query.wasPrefetched = true\n        return res\n      } catch (err) {\n        if (config.throwOnError) {\n          throw err\n        }\n      }\n    }\n\n    return query.state.data\n  }\n\n  cache.setQueryData = (queryKey, updater, { exact, ...config } = {}) => {\n    let queries = findQueries(queryKey, { exact })\n\n    if (!queries.length && typeof queryKey !== 'function') {\n      queries = [\n        cache._buildQuery(queryKey, undefined, () => new Promise(noop), {\n          ...defaultConfigRef.current,\n          ...config,\n        }),\n      ]\n    }\n\n    queries.forEach(d => d.setData(updater))\n  }\n\n  function makeQuery(options) {\n    const reducer = options.config.queryReducer || defaultQueryReducer\n\n    const noQueryHash = typeof options.queryHash === 'undefined'\n\n    const initialData =\n      typeof options.config.initialData === 'function'\n        ? options.config.initialData()\n        : options.config.initialData\n\n    const hasInitialData = typeof initialData !== 'undefined'\n\n    const isStale = noQueryHash ? true : !hasInitialData\n\n    const manual = options.config.manual\n\n    const initialStatus =\n      noQueryHash || manual || hasInitialData ? statusSuccess : statusLoading\n\n    const query = {\n      ...options,\n      instances: [],\n      state: reducer(undefined, {\n        type: actionInit,\n        initialStatus,\n        initialData,\n        hasInitialData,\n        isStale,\n        manual,\n      }),\n    }\n\n    const dispatch = action => {\n      query.state = reducer(query.state, action)\n      query.instances.forEach(d => d.onStateUpdate(query.state))\n      notifyGlobalListeners()\n    }\n\n    query.scheduleStaleTimeout = () => {\n      if (query.config.staleTime === Infinity) {\n        return\n      }\n      query.staleTimeout = setTimeout(() => {\n        if (queryCache.getQuery(query.queryKey)) {\n          dispatch({ type: actionMarkStale })\n        }\n      }, query.config.staleTime)\n    }\n\n    query.scheduleGarbageCollection = () => {\n      dispatch({ type: actionMarkGC })\n      query.cacheTimeout = setTimeout(\n        () => {\n          cache.removeQueries(\n            d =>\n              d.state.markedForGarbageCollection &&\n              d.queryHash === query.queryHash\n          )\n        },\n        typeof query.state.data === 'undefined' &&\n          query.state.status !== 'error'\n          ? 0\n          : query.config.cacheTime\n      )\n    }\n\n    query.heal = () => {\n      // Stop the query from being garbage collected\n      clearTimeout(query.cacheTimeout)\n\n      // Mark the query as not cancelled\n      query.cancelled = null\n    }\n\n    query.subscribe = instance => {\n      let found = query.instances.find(d => d.id === instance.id)\n\n      if (found) {\n        Object.assign(found, instance)\n      } else {\n        found = {\n          onStateUpdate: noop,\n          ...instance,\n        }\n        query.instances.push(instance)\n      }\n\n      query.heal()\n\n      // Return the unsubscribe function\n      return () => {\n        query.instances = query.instances.filter(d => d.id !== instance.id)\n\n        if (!query.instances.length) {\n          // Cancel any side-effects\n          query.cancelled = cancelledError\n\n          if (query.cancelQueries) {\n            query.cancelQueries()\n          }\n\n          // Schedule garbage collection\n          query.scheduleGarbageCollection()\n        }\n      }\n    }\n\n    // Set up the fetch function\n    const tryFetchData = async (queryFn, ...args) => {\n      try {\n        // Perform the query\n        const promise = queryFn(...query.config.queryFnParamsFilter(args))\n\n        query.cancelQueries = () => promise.cancel?.()\n\n        const data = await promise\n\n        delete query.cancelQueries\n        if (query.cancelled) throw query.cancelled\n\n        return data\n      } catch (error) {\n        delete query.cancelQueries\n        if (query.cancelled) throw query.cancelled\n\n        // If we fail, increase the failureCount\n        dispatch({ type: actionFailed })\n\n        // Do we need to retry the request?\n        if (\n          query.config.retry === true ||\n          query.state.failureCount <= query.config.retry ||\n          (typeof query.config.retry === 'function' &&\n            query.config.retry(query.state.failureCount, error))\n        ) {\n          // Only retry if the document is visible\n          if (!isDocumentVisible()) {\n            // set this flag to continue fetch retries on focus\n            query.shouldContinueRetryOnFocus = true\n            return new Promise(noop)\n          }\n\n          delete query.shouldContinueRetryOnFocus\n\n          // Determine the retryDelay\n          const delay = functionalUpdate(\n            query.config.retryDelay,\n            query.state.failureCount\n          )\n\n          // Return a new promise with the retry\n          return await new Promise((resolve, reject) => {\n            // Keep track of the retry timeout\n            setTimeout(async () => {\n              if (query.cancelled) return reject(query.cancelled)\n\n              try {\n                const data = await tryFetchData(queryFn, ...args)\n                if (query.cancelled) return reject(query.cancelled)\n                resolve(data)\n              } catch (error) {\n                if (query.cancelled) return reject(query.cancelled)\n                reject(error)\n              }\n            }, delay)\n          })\n        }\n\n        throw error\n      }\n    }\n\n    query.fetch = async ({ force, __queryFn = query.queryFn } = {}) => {\n      // Don't refetch fresh queries that don't have a queryHash\n\n      if (!query.queryHash || (!query.state.isStale && !force)) {\n        return\n      }\n\n      // Create a new promise for the query cache if necessary\n      if (!query.promise) {\n        query.promise = (async () => {\n          // If there are any retries pending for this query, kill them\n          query.cancelled = null\n\n          try {\n            // Set up the query refreshing state\n            dispatch({ type: actionFetch })\n\n            // Try to fetch\n            let data = await tryFetchData(\n              __queryFn,\n              ...query.queryKey,\n              ...query.queryVariables\n            )\n\n            query.setData(data)\n\n            query.instances.forEach(\n              instance =>\n                instance.onSuccess && instance.onSuccess(query.state.data)\n            )\n\n            query.instances.forEach(\n              instance =>\n                instance.onSettled && instance.onSettled(query.state.data, null)\n            )\n\n            delete query.promise\n\n            return data\n          } catch (error) {\n            dispatch({\n              type: actionError,\n              cancelled: error === query.cancelled,\n              error,\n            })\n\n            delete query.promise\n\n            if (error !== query.cancelled) {\n              query.instances.forEach(\n                instance => instance.onError && instance.onError(error)\n              )\n\n              query.instances.forEach(\n                instance =>\n                  instance.onSettled && instance.onSettled(undefined, error)\n              )\n\n              throw error\n            }\n          }\n        })()\n      }\n\n      return query.promise\n    }\n\n    query.setData = updater => {\n      // Set data and mark it as cached\n      dispatch({ type: actionSuccess, updater })\n\n      // Schedule a fresh invalidation!\n      clearTimeout(query.staleTimeout)\n      query.scheduleStaleTimeout()\n    }\n\n    return query\n  }\n\n  return cache\n}\n\nexport function defaultQueryReducer(state, action) {\n  switch (action.type) {\n    case actionInit:\n      return {\n        status: action.initialStatus,\n        error: null,\n        isFetching: action.hasInitialData ? false : !action.manual,\n        canFetchMore: false,\n        failureCount: 0,\n        isStale: action.isStale,\n        markedForGarbageCollection: false,\n        data: action.initialData,\n        updatedAt: action.hasInitialData ? Date.now() : 0,\n      }\n    case actionFailed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case actionMarkStale:\n      return {\n        ...state,\n        isStale: true,\n      }\n    case actionMarkGC: {\n      return {\n        ...state,\n        markedForGarbageCollection: true,\n      }\n    }\n    case actionFetch:\n      return {\n        ...state,\n        status: state.status === statusError ? statusLoading : state.status,\n        isFetching: true,\n        failureCount: 0,\n      }\n    case actionSuccess:\n      return {\n        ...state,\n        status: statusSuccess,\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: false,\n        isFetching: false,\n        canFetchMore: action.canFetchMore,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case actionError:\n      return {\n        ...state,\n        isFetching: false,\n        isStale: true,\n        ...(!action.cancelled && {\n          status: statusError,\n          error: action.error,\n        }),\n      }\n    default:\n      throw new Error()\n  }\n}\n","import { isOnline, isDocumentVisible, Console, isServer } from './utils'\nimport { defaultConfigRef } from './config'\nimport { queryCache } from './queryCache'\n\nconst visibilityChangeEvent = 'visibilitychange'\nconst focusEvent = 'focus'\n\nconst onWindowFocus = () => {\n  const { refetchAllOnWindowFocus } = defaultConfigRef.current\n\n  if (isDocumentVisible() && isOnline()) {\n    queryCache\n      .refetchQueries(query => {\n        if (!query.instances.length) {\n          return false\n        }\n\n        if (query.config.manual === true) {\n          return false\n        }\n\n        if (query.shouldContinueRetryOnFocus) {\n          // delete promise, so `fetch` will create new one\n          delete query.promise\n          return true\n        }\n\n        if (typeof query.config.refetchOnWindowFocus === 'undefined') {\n          return refetchAllOnWindowFocus\n        } else {\n          return query.config.refetchOnWindowFocus\n        }\n      })\n      .catch(Console.error)\n  }\n}\n\nlet removePreviousHandler\n\nexport function setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler()\n  }\n  // Sub the new watcher\n  removePreviousHandler = callback(onWindowFocus)\n}\n\nsetFocusHandler(handleFocus => {\n  // Listen to visibillitychange and focus\n  if (!isServer && window?.addEventListener) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false)\n    window.addEventListener(focusEvent, handleFocus, false)\n\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus)\n      window.removeEventListener(focusEvent, handleFocus)\n    }\n  }\n})\n","import React from 'react'\n\nimport { queryCache } from './queryCache'\n\nexport function useIsFetching() {\n  const [state, setState] = React.useState({})\n\n  React.useEffect(() => {\n    return queryCache.subscribe(() => setState({}))\n  }, [])\n\n  return React.useMemo(() => state && queryCache.isFetching, [state])\n}\n","import React from 'react'\n\n//\n\nimport { useConfigContext } from './config'\nimport {\n  statusIdle,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  useGetLatest,\n  Console,\n  uid,\n  useMountedCallback,\n  noop,\n} from './utils'\n\nconst getDefaultState = () => ({\n  status: statusIdle,\n  data: undefined,\n  error: null,\n})\n\nconst actionReset = {}\nconst actionLoading = {}\nconst actionResolve = {}\nconst actionReject = {}\n\nfunction mutationReducer(state, action) {\n  if (action.type === actionReset) {\n    return getDefaultState()\n  }\n  if (action.type === actionLoading) {\n    return {\n      status: statusLoading,\n    }\n  }\n  if (action.type === actionResolve) {\n    return {\n      status: statusSuccess,\n      data: action.data,\n    }\n  }\n  if (action.type === actionReject) {\n    return {\n      status: statusError,\n      error: action.error,\n    }\n  }\n  throw new Error()\n}\n\nexport function useMutation(mutationFn, config = {}) {\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer,\n    null,\n    getDefaultState\n  )\n\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const getMutationFn = useGetLatest(mutationFn)\n\n  const getConfig = useGetLatest({\n    ...useConfigContext(),\n    ...config,\n  })\n\n  const latestMutationRef = React.useRef()\n\n  const mutate = React.useCallback(\n    async (\n      variables,\n      { onSuccess = noop, onError = noop, onSettled = noop, throwOnError } = {}\n    ) => {\n      const config = getConfig()\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = async () => latestMutationRef.current === mutationId\n\n      dispatch({ type: actionLoading })\n\n      let snapshotValue\n\n      try {\n        snapshotValue = await config.onMutate(variables)\n\n        let data\n\n        if (isLatest()) {\n          data = await getMutationFn()(variables)\n        }\n\n        if (isLatest()) {\n          await onSuccess(data, variables)\n        }\n\n        if (isLatest()) {\n          await config.onSuccess(data, variables)\n        }\n\n        if (isLatest()) {\n          await onSettled(data, null, variables)\n        }\n\n        if (isLatest()) {\n          await config.onSettled(data, null, variables)\n        }\n\n        if (isLatest()) {\n          dispatch({ type: actionResolve, data })\n        }\n\n        return data\n      } catch (error) {\n        if (isLatest()) {\n          Console.error(error)\n          await onError(error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await config.onError(error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await onSettled(undefined, error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await config.onSettled(undefined, error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          dispatch({ type: actionReject, error })\n\n          if (throwOnError ?? config.throwOnError) {\n            throw error\n          }\n        }\n      }\n    },\n    [dispatch, getConfig, getMutationFn]\n  )\n\n  const reset = React.useCallback(() => dispatch({ type: actionReset }), [\n    dispatch,\n  ])\n\n  React.useEffect(() => {\n    if (getConfig().useErrorBoundary && state.error) {\n      throw state.error\n    }\n  }, [getConfig, state.error])\n\n  return [mutate, { ...state, reset }]\n}\n","import React from 'react'\n\n//\n\nimport { queryCache } from './queryCache'\nimport { useConfigContext } from './config'\nimport {\n  useUid,\n  isDocumentVisible,\n  Console,\n  useGetLatest,\n  useMountedCallback,\n} from './utils'\n\nexport function useBaseQuery(queryKey, queryVariables, queryFn, config = {}) {\n  const instanceId = useUid()\n\n  config = {\n    ...useConfigContext(),\n    ...config,\n  }\n\n  const queryRef = React.useRef()\n\n  const newQuery = queryCache._buildQuery(\n    queryKey,\n    queryVariables,\n    queryFn,\n    config\n  )\n\n  const useCachedQuery =\n    queryRef.current &&\n    typeof queryRef.current.queryHash === 'undefined' &&\n    typeof newQuery.queryHash === 'undefined'\n\n  // Do not use new query with undefined queryHash, if previous query also had undefined queryHash.\n  // Otherwise this will cause infinite loop.\n  if (!useCachedQuery) {\n    queryRef.current = newQuery\n  }\n\n  const query = queryRef.current\n\n  const [, unsafeRerender] = React.useState()\n\n  const rerender = useMountedCallback(unsafeRerender)\n\n  const getLatestConfig = useGetLatest(config)\n  const refetch = React.useCallback(\n    async ({ throwOnError, ...rest } = {}) => {\n      try {\n        return await query.fetch(rest)\n      } catch (err) {\n        if (throwOnError) {\n          throw err\n        }\n      }\n    },\n    [query]\n  )\n\n  // Subscribe to the query and maybe trigger fetch\n  React.useEffect(() => {\n    const unsubscribeFromQuery = query.subscribe({\n      id: instanceId,\n      onStateUpdate: () => rerender({}),\n      onSuccess: data => getLatestConfig().onSuccess(data),\n      onError: err => getLatestConfig().onError(err),\n      onSettled: (data, err) => getLatestConfig().onSettled(data, err),\n    })\n\n    // Perform the initial fetch for this query if necessary\n    if (\n      !getLatestConfig().manual && // Don't auto fetch if config is set to manual query\n      !query.wasPrefetched && // Don't double fetch for prefetched queries\n      !query.wasSuspensed && // Don't double fetch for suspense\n      query.state.isStale && // Only refetch if stale\n      (getLatestConfig().refetchOnMount || query.instances.length === 1)\n    ) {\n      refetch().catch(Console.error)\n    }\n\n    query.wasPrefetched = false\n    query.wasSuspensed = false\n\n    return unsubscribeFromQuery\n  }, [getLatestConfig, instanceId, query, refetch, rerender])\n\n  // Handle refetch interval\n  React.useEffect(() => {\n    if (\n      config.refetchInterval &&\n      (!query.refetchInterval || config.refetchInterval < query.refetchInterval)\n    ) {\n      clearInterval(query.refetchInterval)\n      query.refetchInterval = setInterval(() => {\n        if (isDocumentVisible() || config.refetchIntervalInBackground) {\n          refetch().catch(Console.error)\n        }\n      }, config.refetchInterval)\n\n      return () => {\n        clearInterval(query.refetchInterval)\n        delete query.refetchInterval\n      }\n    }\n  }, [\n    config.refetchInterval,\n    config.refetchIntervalInBackground,\n    query.refetchInterval,\n    refetch,\n  ])\n\n  return {\n    ...query.state,\n    config,\n    query,\n    refetch,\n  }\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, handleSuspense } from './utils'\n\nexport function useQuery(...args) {\n  const query = useBaseQuery(...getQueryArgs(args))\n\n  handleSuspense(query)\n\n  return query\n}\n","import React from 'react'\n\n//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, handleSuspense } from './utils'\n\nexport function usePaginatedQuery(...args) {\n  let [queryKey, queryVariables, queryFn, config = {}] = getQueryArgs(args)\n\n  const lastDataRef = React.useRef()\n\n  // If latestData is set, don't use initialData\n  if (typeof lastDataRef.current !== 'undefined') {\n    delete config.initialData\n  }\n\n  const query = useBaseQuery(queryKey, queryVariables, queryFn, config)\n\n  let { data: latestData, status } = query\n\n  React.useEffect(() => {\n    if (status === 'success' && typeof latestData !== 'undefined') {\n      lastDataRef.current = latestData\n    }\n  }, [latestData, status])\n\n  let resolvedData = latestData\n\n  if (typeof resolvedData === 'undefined') {\n    resolvedData = lastDataRef.current\n  }\n\n  if (typeof resolvedData !== 'undefined') {\n    status = 'success'\n  }\n\n  handleSuspense(query)\n\n  return {\n    ...query,\n    resolvedData,\n    latestData,\n    status,\n  }\n}\n","import React from 'react'\n\n//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, useGetLatest, handleSuspense } from './utils'\n\nexport function useInfiniteQuery(...args) {\n  const queryInfoRef = React.useRef()\n  let [queryKey, queryVariables, queryFn, config = {}] = getQueryArgs(args)\n\n  const { getFetchMore } = config\n  const getGetFetchMore = useGetLatest(getFetchMore)\n\n  // The default queryFn will query all pages and map them together\n  const originalQueryFn = queryFn\n\n  queryFn = async () => {\n    const data = await Promise.all(\n      queryInfoRef.current.query.pageVariables.map(args =>\n        originalQueryFn(...args)\n      )\n    )\n    queryInfoRef.current.query.canFetchMore = getGetFetchMore()(\n      data[data.length - 1],\n      data\n    )\n    return data\n  }\n\n  const queryInfo = useBaseQuery(queryKey, queryVariables, queryFn, config)\n\n  if (\n    typeof queryInfo.query.canFetchMore === 'undefined' &&\n    typeof queryInfo.data !== 'undefined'\n  ) {\n    queryInfo.query.canFetchMore = getGetFetchMore()(\n      queryInfo.data[queryInfo.data.length - 1],\n      queryInfo.data\n    )\n  }\n\n  queryInfoRef.current = queryInfo\n\n  let {\n    refetch,\n    data = [],\n    query: { canFetchMore },\n  } = queryInfo\n\n  // Here we seed the pageVariabes for the query\n  if (!queryInfo.query.pageVariables) {\n    queryInfo.query.pageVariables = [\n      [...queryInfo.query.queryKey, ...queryInfo.query.queryVariables],\n    ]\n  }\n\n  const fetchMore = React.useCallback(\n    (fetchMoreInfo = queryInfoRef.current.query.canFetchMore) =>\n      queryInfoRef.current.query.canFetchMore\n        ? refetch({\n            force: true,\n            __queryFn: async (...args) => {\n              try {\n                queryInfoRef.current.query.isFetchingMore = true\n                const newArgs = [...args, fetchMoreInfo]\n                queryInfoRef.current.query.pageVariables.push(newArgs)\n                const data = [\n                  ...queryInfoRef.current.data,\n                  await originalQueryFn(...newArgs),\n                ]\n                queryInfoRef.current.query.canFetchMore = getGetFetchMore()(\n                  data[data.length - 1],\n                  data\n                )\n                return data\n              } finally {\n                queryInfoRef.current.query.isFetchingMore = false\n              }\n            },\n          })\n        : void 0,\n    [getGetFetchMore, originalQueryFn, refetch]\n  )\n\n  const isFetchingMore = React.useMemo(() => {\n    return !!queryInfo.query.isFetchingMore\n  }, [queryInfo.query.isFetchingMore])\n\n  handleSuspense(queryInfo)\n\n  return {\n    ...queryInfo,\n    data,\n    canFetchMore,\n    fetchMore,\n    isFetchingMore,\n  }\n}\n"],"names":["statusIdle","statusLoading","statusError","statusSuccess","_uid","uid","cancelledError","isServer","window","noop","Console","console","error","warn","log","setConsole","c","useGetLatest","obj","ref","React","useRef","current","useCallback","functionalUpdate","updater","old","stableStringifyReplacer","_","value","isObject","Object","assign","keys","sort","map","key","stableStringify","JSON","stringify","a","Array","isArray","isDocumentVisible","document","undefined","visibilityState","getQueryArgs","args","hasOwnProperty","queryKey","variables","queryFn","config","Error","useMountedCallback","callback","mounted","handleSuspense","query","suspense","useErrorBoundary","status","wasSuspensed","refetch","configContext","createContext","defaultConfigRef","retry","retryDelay","attemptIndex","Math","min","staleTime","cacheTime","refetchAllOnWindowFocus","refetchInterval","queryKeySerializerFn","defaultQueryKeySerializerFn","queryHash","parse","queryFnParamsFilter","d","throwOnError","onMutate","onSuccess","onError","onSettled","refetchOnMount","useConfigContext","useContext","ReactQueryConfigProvider","children","configContextValue","newConfig","useMemo","Provider","then","direct","Promise","resolve","body","recover","result","e","f","i","arguments","length","apply","this","reject","queryCache","listeners","cache","queries","isFetching","notifyGlobalListeners","values","reduce","acc","state","forEach","subscribe","cb","push","splice","indexOf","clear","findQueries","predicate","exact","deepIncludes","b","some","filter","getQueries","getQuery","getQueryData","_cache$getQuery","data","removeQueries","foundQueries","clearTimeout","staleTimeout","refetchQueries","force","all","fetch","err","_buildQuery","userQueryKey","queryVariables","options","reducer","queryReducer","defaultQueryReducer","noQueryHash","initialData","hasInitialData","isStale","manual","instances","type","actionInit","initialStatus","dispatch","action","onStateUpdate","scheduleStaleTimeout","Infinity","setTimeout","actionMarkStale","scheduleGarbageCollection","actionMarkGC","cacheTimeout","markedForGarbageCollection","heal","cancelled","instance","found","find","id","cancelQueries","tryFetchData","promise","cancel","actionFailed","failureCount","shouldContinueRetryOnFocus","delay","__queryFn","_async","actionFetch","setData","actionError","actionSuccess","makeQuery","prefetchQuery","res","wasPrefetched","setQueryData","makeQueryCache","canFetchMore","updatedAt","Date","now","removePreviousHandler","onWindowFocus","navigator","onLine","refetchOnWindowFocus","catch","setFocusHandler","useIsFetching","useState","setState","useEffect","_await","handleFocus","_window","addEventListener","removeEventListener","getDefaultState","_empty","actionReset","_awaitIgnored","actionLoading","_invoke","actionResolve","actionReject","mutationReducer","useMutation","mutationFn","useReducer","getMutationFn","getConfig","latestMutationRef","mutate","mutationId","snapshotValue","isLatest","reset","useBaseQuery","instanceId","queryRef","newQuery","rerender","getLatestConfig","rest","unsubscribeFromQuery","clearInterval","setInterval","refetchIntervalInBackground","useQuery","usePaginatedQuery","lastDataRef","latestData","resolvedData","thrown","finalizer","bind","useInfiniteQuery","queryInfoRef","getFetchMore","getGetFetchMore","originalQueryFn","queryInfo","pageVariables","fetchMore","fetchMoreInfo","isFetchingMore","newArgs"],"mappings":"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"}